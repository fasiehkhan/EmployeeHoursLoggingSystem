{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst coverage = require('istanbul-lib-coverage');\nconst Path = require('./path');\nconst {\n  BaseNode,\n  BaseTree\n} = require('./tree');\nclass ReportNode extends BaseNode {\n  constructor(path, fileCoverage) {\n    super();\n    this.path = path;\n    this.parent = null;\n    this.fileCoverage = fileCoverage;\n    this.children = [];\n  }\n  static createRoot(children) {\n    const root = new ReportNode(new Path([]));\n    children.forEach(child => {\n      root.addChild(child);\n    });\n    return root;\n  }\n  addChild(child) {\n    child.parent = this;\n    this.children.push(child);\n  }\n  asRelative(p) {\n    if (p.substring(0, 1) === '/') {\n      return p.substring(1);\n    }\n    return p;\n  }\n  getQualifiedName() {\n    return this.asRelative(this.path.toString());\n  }\n  getRelativeName() {\n    const parent = this.getParent();\n    const myPath = this.path;\n    let relPath;\n    let i;\n    const parentPath = parent ? parent.path : new Path([]);\n    if (parentPath.ancestorOf(myPath)) {\n      relPath = new Path(myPath.elements());\n      for (i = 0; i < parentPath.length; i += 1) {\n        relPath.shift();\n      }\n      return this.asRelative(relPath.toString());\n    }\n    return this.asRelative(this.path.toString());\n  }\n  getParent() {\n    return this.parent;\n  }\n  getChildren() {\n    return this.children;\n  }\n  isSummary() {\n    return !this.fileCoverage;\n  }\n  getFileCoverage() {\n    return this.fileCoverage;\n  }\n  getCoverageSummary(filesOnly) {\n    const cacheProp = `c_${filesOnly ? 'files' : 'full'}`;\n    let summary;\n    if (Object.prototype.hasOwnProperty.call(this, cacheProp)) {\n      return this[cacheProp];\n    }\n    if (!this.isSummary()) {\n      summary = this.getFileCoverage().toSummary();\n    } else {\n      let count = 0;\n      summary = coverage.createCoverageSummary();\n      this.getChildren().forEach(child => {\n        if (filesOnly && child.isSummary()) {\n          return;\n        }\n        count += 1;\n        summary.merge(child.getCoverageSummary(filesOnly));\n      });\n      if (count === 0 && filesOnly) {\n        summary = null;\n      }\n    }\n    this[cacheProp] = summary;\n    return summary;\n  }\n}\nclass ReportTree extends BaseTree {\n  constructor(root, childPrefix) {\n    super(root);\n    const maybePrefix = node => {\n      if (childPrefix && !node.isRoot()) {\n        node.path.unshift(childPrefix);\n      }\n    };\n    this.visit({\n      onDetail: maybePrefix,\n      onSummary(node) {\n        maybePrefix(node);\n        node.children.sort((a, b) => {\n          const astr = a.path.toString();\n          const bstr = b.path.toString();\n          return astr < bstr ? -1 : astr > bstr ? 1 : /* istanbul ignore next */0;\n        });\n      }\n    });\n  }\n}\nfunction findCommonParent(paths) {\n  return paths.reduce((common, path) => common.commonPrefixPath(path), paths[0] || new Path([]));\n}\nfunction findOrCreateParent(parentPath, nodeMap) {\n  let created = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};\n  let parent = nodeMap[parentPath.toString()];\n  if (!parent) {\n    parent = new ReportNode(parentPath);\n    nodeMap[parentPath.toString()] = parent;\n    created(parentPath, parent);\n  }\n  return parent;\n}\nfunction toDirParents(list) {\n  const nodeMap = Object.create(null);\n  list.forEach(o => {\n    const parent = findOrCreateParent(o.path.parent(), nodeMap);\n    parent.addChild(new ReportNode(o.path, o.fileCoverage));\n  });\n  return Object.values(nodeMap);\n}\nfunction addAllPaths(topPaths, nodeMap, path, node) {\n  const parent = findOrCreateParent(path.parent(), nodeMap, (parentPath, parent) => {\n    if (parentPath.hasParent()) {\n      addAllPaths(topPaths, nodeMap, parentPath, parent);\n    } else {\n      topPaths.push(parent);\n    }\n  });\n  parent.addChild(node);\n}\nfunction foldIntoOneDir(node, parent) {\n  const {\n    children\n  } = node;\n  if (children.length === 1 && !children[0].fileCoverage) {\n    children[0].parent = parent;\n    return foldIntoOneDir(children[0], parent);\n  }\n  node.children = children.map(child => foldIntoOneDir(child, node));\n  return node;\n}\nfunction pkgSummaryPrefix(dirParents, commonParent) {\n  if (!dirParents.some(dp => dp.path.length === 0)) {\n    return;\n  }\n  if (commonParent.length === 0) {\n    return 'root';\n  }\n  return commonParent.name();\n}\nclass SummarizerFactory {\n  constructor(coverageMap) {\n    let defaultSummarizer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'pkg';\n    this._coverageMap = coverageMap;\n    this._defaultSummarizer = defaultSummarizer;\n    this._initialList = coverageMap.files().map(filePath => ({\n      filePath,\n      path: new Path(filePath),\n      fileCoverage: coverageMap.fileCoverageFor(filePath)\n    }));\n    this._commonParent = findCommonParent(this._initialList.map(o => o.path.parent()));\n    if (this._commonParent.length > 0) {\n      this._initialList.forEach(o => {\n        o.path.splice(0, this._commonParent.length);\n      });\n    }\n  }\n  get defaultSummarizer() {\n    return this[this._defaultSummarizer];\n  }\n  get flat() {\n    if (!this._flat) {\n      this._flat = new ReportTree(ReportNode.createRoot(this._initialList.map(node => new ReportNode(node.path, node.fileCoverage))));\n    }\n    return this._flat;\n  }\n  _createPkg() {\n    const dirParents = toDirParents(this._initialList);\n    if (dirParents.length === 1) {\n      return new ReportTree(dirParents[0]);\n    }\n    return new ReportTree(ReportNode.createRoot(dirParents), pkgSummaryPrefix(dirParents, this._commonParent));\n  }\n  get pkg() {\n    if (!this._pkg) {\n      this._pkg = this._createPkg();\n    }\n    return this._pkg;\n  }\n  _createNested() {\n    const nodeMap = Object.create(null);\n    const topPaths = [];\n    this._initialList.forEach(o => {\n      const node = new ReportNode(o.path, o.fileCoverage);\n      addAllPaths(topPaths, nodeMap, o.path, node);\n    });\n    const topNodes = topPaths.map(node => foldIntoOneDir(node));\n    if (topNodes.length === 1) {\n      return new ReportTree(topNodes[0]);\n    }\n    return new ReportTree(ReportNode.createRoot(topNodes));\n  }\n  get nested() {\n    if (!this._nested) {\n      this._nested = this._createNested();\n    }\n    return this._nested;\n  }\n}\nmodule.exports = SummarizerFactory;","map":{"version":3,"names":["coverage","require","Path","BaseNode","BaseTree","ReportNode","constructor","path","fileCoverage","parent","children","createRoot","root","forEach","child","addChild","push","asRelative","p","substring","getQualifiedName","toString","getRelativeName","getParent","myPath","relPath","i","parentPath","ancestorOf","elements","length","shift","getChildren","isSummary","getFileCoverage","getCoverageSummary","filesOnly","cacheProp","summary","Object","prototype","hasOwnProperty","call","toSummary","count","createCoverageSummary","merge","ReportTree","childPrefix","maybePrefix","node","isRoot","unshift","visit","onDetail","onSummary","sort","a","b","astr","bstr","findCommonParent","paths","reduce","common","commonPrefixPath","findOrCreateParent","nodeMap","created","toDirParents","list","create","o","values","addAllPaths","topPaths","hasParent","foldIntoOneDir","map","pkgSummaryPrefix","dirParents","commonParent","some","dp","name","SummarizerFactory","coverageMap","defaultSummarizer","_coverageMap","_defaultSummarizer","_initialList","files","filePath","fileCoverageFor","_commonParent","splice","flat","_flat","_createPkg","pkg","_pkg","_createNested","topNodes","nested","_nested","module","exports"],"sources":["/Users/fasiehkhan/Documents/GitHub/EmployeeHoursLoggingSystem/node_modules/istanbul-lib-report/lib/summarizer-factory.js"],"sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst coverage = require('istanbul-lib-coverage');\nconst Path = require('./path');\nconst { BaseNode, BaseTree } = require('./tree');\n\nclass ReportNode extends BaseNode {\n    constructor(path, fileCoverage) {\n        super();\n\n        this.path = path;\n        this.parent = null;\n        this.fileCoverage = fileCoverage;\n        this.children = [];\n    }\n\n    static createRoot(children) {\n        const root = new ReportNode(new Path([]));\n\n        children.forEach(child => {\n            root.addChild(child);\n        });\n\n        return root;\n    }\n\n    addChild(child) {\n        child.parent = this;\n        this.children.push(child);\n    }\n\n    asRelative(p) {\n        if (p.substring(0, 1) === '/') {\n            return p.substring(1);\n        }\n        return p;\n    }\n\n    getQualifiedName() {\n        return this.asRelative(this.path.toString());\n    }\n\n    getRelativeName() {\n        const parent = this.getParent();\n        const myPath = this.path;\n        let relPath;\n        let i;\n        const parentPath = parent ? parent.path : new Path([]);\n        if (parentPath.ancestorOf(myPath)) {\n            relPath = new Path(myPath.elements());\n            for (i = 0; i < parentPath.length; i += 1) {\n                relPath.shift();\n            }\n            return this.asRelative(relPath.toString());\n        }\n        return this.asRelative(this.path.toString());\n    }\n\n    getParent() {\n        return this.parent;\n    }\n\n    getChildren() {\n        return this.children;\n    }\n\n    isSummary() {\n        return !this.fileCoverage;\n    }\n\n    getFileCoverage() {\n        return this.fileCoverage;\n    }\n\n    getCoverageSummary(filesOnly) {\n        const cacheProp = `c_${filesOnly ? 'files' : 'full'}`;\n        let summary;\n\n        if (Object.prototype.hasOwnProperty.call(this, cacheProp)) {\n            return this[cacheProp];\n        }\n\n        if (!this.isSummary()) {\n            summary = this.getFileCoverage().toSummary();\n        } else {\n            let count = 0;\n            summary = coverage.createCoverageSummary();\n            this.getChildren().forEach(child => {\n                if (filesOnly && child.isSummary()) {\n                    return;\n                }\n                count += 1;\n                summary.merge(child.getCoverageSummary(filesOnly));\n            });\n            if (count === 0 && filesOnly) {\n                summary = null;\n            }\n        }\n        this[cacheProp] = summary;\n        return summary;\n    }\n}\n\nclass ReportTree extends BaseTree {\n    constructor(root, childPrefix) {\n        super(root);\n\n        const maybePrefix = node => {\n            if (childPrefix && !node.isRoot()) {\n                node.path.unshift(childPrefix);\n            }\n        };\n        this.visit({\n            onDetail: maybePrefix,\n            onSummary(node) {\n                maybePrefix(node);\n                node.children.sort((a, b) => {\n                    const astr = a.path.toString();\n                    const bstr = b.path.toString();\n                    return astr < bstr\n                        ? -1\n                        : astr > bstr\n                        ? 1\n                        : /* istanbul ignore next */ 0;\n                });\n            }\n        });\n    }\n}\n\nfunction findCommonParent(paths) {\n    return paths.reduce(\n        (common, path) => common.commonPrefixPath(path),\n        paths[0] || new Path([])\n    );\n}\n\nfunction findOrCreateParent(parentPath, nodeMap, created = () => {}) {\n    let parent = nodeMap[parentPath.toString()];\n\n    if (!parent) {\n        parent = new ReportNode(parentPath);\n        nodeMap[parentPath.toString()] = parent;\n        created(parentPath, parent);\n    }\n\n    return parent;\n}\n\nfunction toDirParents(list) {\n    const nodeMap = Object.create(null);\n    list.forEach(o => {\n        const parent = findOrCreateParent(o.path.parent(), nodeMap);\n        parent.addChild(new ReportNode(o.path, o.fileCoverage));\n    });\n\n    return Object.values(nodeMap);\n}\n\nfunction addAllPaths(topPaths, nodeMap, path, node) {\n    const parent = findOrCreateParent(\n        path.parent(),\n        nodeMap,\n        (parentPath, parent) => {\n            if (parentPath.hasParent()) {\n                addAllPaths(topPaths, nodeMap, parentPath, parent);\n            } else {\n                topPaths.push(parent);\n            }\n        }\n    );\n\n    parent.addChild(node);\n}\n\nfunction foldIntoOneDir(node, parent) {\n    const { children } = node;\n    if (children.length === 1 && !children[0].fileCoverage) {\n        children[0].parent = parent;\n        return foldIntoOneDir(children[0], parent);\n    }\n    node.children = children.map(child => foldIntoOneDir(child, node));\n    return node;\n}\n\nfunction pkgSummaryPrefix(dirParents, commonParent) {\n    if (!dirParents.some(dp => dp.path.length === 0)) {\n        return;\n    }\n\n    if (commonParent.length === 0) {\n        return 'root';\n    }\n\n    return commonParent.name();\n}\n\nclass SummarizerFactory {\n    constructor(coverageMap, defaultSummarizer = 'pkg') {\n        this._coverageMap = coverageMap;\n        this._defaultSummarizer = defaultSummarizer;\n        this._initialList = coverageMap.files().map(filePath => ({\n            filePath,\n            path: new Path(filePath),\n            fileCoverage: coverageMap.fileCoverageFor(filePath)\n        }));\n        this._commonParent = findCommonParent(\n            this._initialList.map(o => o.path.parent())\n        );\n        if (this._commonParent.length > 0) {\n            this._initialList.forEach(o => {\n                o.path.splice(0, this._commonParent.length);\n            });\n        }\n    }\n\n    get defaultSummarizer() {\n        return this[this._defaultSummarizer];\n    }\n\n    get flat() {\n        if (!this._flat) {\n            this._flat = new ReportTree(\n                ReportNode.createRoot(\n                    this._initialList.map(\n                        node => new ReportNode(node.path, node.fileCoverage)\n                    )\n                )\n            );\n        }\n\n        return this._flat;\n    }\n\n    _createPkg() {\n        const dirParents = toDirParents(this._initialList);\n        if (dirParents.length === 1) {\n            return new ReportTree(dirParents[0]);\n        }\n\n        return new ReportTree(\n            ReportNode.createRoot(dirParents),\n            pkgSummaryPrefix(dirParents, this._commonParent)\n        );\n    }\n\n    get pkg() {\n        if (!this._pkg) {\n            this._pkg = this._createPkg();\n        }\n\n        return this._pkg;\n    }\n\n    _createNested() {\n        const nodeMap = Object.create(null);\n        const topPaths = [];\n        this._initialList.forEach(o => {\n            const node = new ReportNode(o.path, o.fileCoverage);\n            addAllPaths(topPaths, nodeMap, o.path, node);\n        });\n\n        const topNodes = topPaths.map(node => foldIntoOneDir(node));\n        if (topNodes.length === 1) {\n            return new ReportTree(topNodes[0]);\n        }\n\n        return new ReportTree(ReportNode.createRoot(topNodes));\n    }\n\n    get nested() {\n        if (!this._nested) {\n            this._nested = this._createNested();\n        }\n\n        return this._nested;\n    }\n}\n\nmodule.exports = SummarizerFactory;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}