{"ast":null,"code":"'use strict';\n\n/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nconst path = require('path');\nconst fs = require('fs');\nconst mkdirp = require('make-dir');\nconst supportsColor = require('supports-color');\n\n/**\n * Base class for writing content\n * @class ContentWriter\n * @constructor\n */\nclass ContentWriter {\n  /**\n   * returns the colorized version of a string. Typically,\n   * content writers that write to files will return the\n   * same string and ones writing to a tty will wrap it in\n   * appropriate escape sequences.\n   * @param {String} str the string to colorize\n   * @param {String} clazz one of `high`, `medium` or `low`\n   * @returns {String} the colorized form of the string\n   */\n  colorize(str /*, clazz*/) {\n    return str;\n  }\n\n  /**\n   * writes a string appended with a newline to the destination\n   * @param {String} str the string to write\n   */\n  println(str) {\n    this.write(`${str}\\n`);\n  }\n\n  /**\n   * closes this content writer. Should be called after all writes are complete.\n   */\n  close() {}\n}\n\n/**\n * a content writer that writes to a file\n * @param {Number} fd - the file descriptor\n * @extends ContentWriter\n * @constructor\n */\nclass FileContentWriter extends ContentWriter {\n  constructor(fd) {\n    super();\n    this.fd = fd;\n  }\n  write(str) {\n    fs.writeSync(this.fd, str);\n  }\n  close() {\n    fs.closeSync(this.fd);\n  }\n}\n\n// allow stdout to be captured for tests.\nlet capture = false;\nlet output = '';\n\n/**\n * a content writer that writes to the console\n * @extends ContentWriter\n * @constructor\n */\nclass ConsoleWriter extends ContentWriter {\n  write(str) {\n    if (capture) {\n      output += str;\n    } else {\n      process.stdout.write(str);\n    }\n  }\n  colorize(str, clazz) {\n    const colors = {\n      low: '31;1',\n      medium: '33;1',\n      high: '32;1'\n    };\n\n    /* istanbul ignore next: different modes for CI and local */\n    if (supportsColor.stdout && colors[clazz]) {\n      return `\\u001b[${colors[clazz]}m${str}\\u001b[0m`;\n    }\n    return str;\n  }\n}\n\n/**\n * utility for writing files under a specific directory\n * @class FileWriter\n * @param {String} baseDir the base directory under which files should be written\n * @constructor\n */\nclass FileWriter {\n  constructor(baseDir) {\n    if (!baseDir) {\n      throw new Error('baseDir must be specified');\n    }\n    this.baseDir = baseDir;\n  }\n\n  /**\n   * static helpers for capturing stdout report output;\n   * super useful for tests!\n   */\n  static startCapture() {\n    capture = true;\n  }\n  static stopCapture() {\n    capture = false;\n  }\n  static getOutput() {\n    return output;\n  }\n  static resetOutput() {\n    output = '';\n  }\n\n  /**\n   * returns a FileWriter that is rooted at the supplied subdirectory\n   * @param {String} subdir the subdirectory under which to root the\n   *  returned FileWriter\n   * @returns {FileWriter}\n   */\n  writerForDir(subdir) {\n    if (path.isAbsolute(subdir)) {\n      throw new Error(`Cannot create subdir writer for absolute path: ${subdir}`);\n    }\n    return new FileWriter(`${this.baseDir}/${subdir}`);\n  }\n\n  /**\n   * copies a file from a source directory to a destination name\n   * @param {String} source path to source file\n   * @param {String} dest relative path to destination file\n   * @param {String} [header=undefined] optional text to prepend to destination\n   *  (e.g., an \"this file is autogenerated\" comment, copyright notice, etc.)\n   */\n  copyFile(source, dest, header) {\n    if (path.isAbsolute(dest)) {\n      throw new Error(`Cannot write to absolute path: ${dest}`);\n    }\n    dest = path.resolve(this.baseDir, dest);\n    mkdirp.sync(path.dirname(dest));\n    let contents;\n    if (header) {\n      contents = header + fs.readFileSync(source, 'utf8');\n    } else {\n      contents = fs.readFileSync(source);\n    }\n    fs.writeFileSync(dest, contents);\n  }\n\n  /**\n   * returns a content writer for writing content to the supplied file.\n   * @param {String|null} file the relative path to the file or the special\n   *  values `\"-\"` or `null` for writing to the console\n   * @returns {ContentWriter}\n   */\n  writeFile(file) {\n    if (file === null || file === '-') {\n      return new ConsoleWriter();\n    }\n    if (path.isAbsolute(file)) {\n      throw new Error(`Cannot write to absolute path: ${file}`);\n    }\n    file = path.resolve(this.baseDir, file);\n    mkdirp.sync(path.dirname(file));\n    return new FileContentWriter(fs.openSync(file, 'w'));\n  }\n}\nmodule.exports = FileWriter;","map":{"version":3,"names":["path","require","fs","mkdirp","supportsColor","ContentWriter","colorize","str","println","write","close","FileContentWriter","constructor","fd","writeSync","closeSync","capture","output","ConsoleWriter","process","stdout","clazz","colors","low","medium","high","FileWriter","baseDir","Error","startCapture","stopCapture","getOutput","resetOutput","writerForDir","subdir","isAbsolute","copyFile","source","dest","header","resolve","sync","dirname","contents","readFileSync","writeFileSync","writeFile","file","openSync","module","exports"],"sources":["/Users/fasiehkhan/Documents/GitHub/EmployeeHoursLoggingSystem/node_modules/istanbul-lib-report/lib/file-writer.js"],"sourcesContent":["'use strict';\n/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nconst path = require('path');\nconst fs = require('fs');\nconst mkdirp = require('make-dir');\nconst supportsColor = require('supports-color');\n\n/**\n * Base class for writing content\n * @class ContentWriter\n * @constructor\n */\nclass ContentWriter {\n    /**\n     * returns the colorized version of a string. Typically,\n     * content writers that write to files will return the\n     * same string and ones writing to a tty will wrap it in\n     * appropriate escape sequences.\n     * @param {String} str the string to colorize\n     * @param {String} clazz one of `high`, `medium` or `low`\n     * @returns {String} the colorized form of the string\n     */\n    colorize(str /*, clazz*/) {\n        return str;\n    }\n\n    /**\n     * writes a string appended with a newline to the destination\n     * @param {String} str the string to write\n     */\n    println(str) {\n        this.write(`${str}\\n`);\n    }\n\n    /**\n     * closes this content writer. Should be called after all writes are complete.\n     */\n    close() {}\n}\n\n/**\n * a content writer that writes to a file\n * @param {Number} fd - the file descriptor\n * @extends ContentWriter\n * @constructor\n */\nclass FileContentWriter extends ContentWriter {\n    constructor(fd) {\n        super();\n\n        this.fd = fd;\n    }\n\n    write(str) {\n        fs.writeSync(this.fd, str);\n    }\n\n    close() {\n        fs.closeSync(this.fd);\n    }\n}\n\n// allow stdout to be captured for tests.\nlet capture = false;\nlet output = '';\n\n/**\n * a content writer that writes to the console\n * @extends ContentWriter\n * @constructor\n */\nclass ConsoleWriter extends ContentWriter {\n    write(str) {\n        if (capture) {\n            output += str;\n        } else {\n            process.stdout.write(str);\n        }\n    }\n\n    colorize(str, clazz) {\n        const colors = {\n            low: '31;1',\n            medium: '33;1',\n            high: '32;1'\n        };\n\n        /* istanbul ignore next: different modes for CI and local */\n        if (supportsColor.stdout && colors[clazz]) {\n            return `\\u001b[${colors[clazz]}m${str}\\u001b[0m`;\n        }\n        return str;\n    }\n}\n\n/**\n * utility for writing files under a specific directory\n * @class FileWriter\n * @param {String} baseDir the base directory under which files should be written\n * @constructor\n */\nclass FileWriter {\n    constructor(baseDir) {\n        if (!baseDir) {\n            throw new Error('baseDir must be specified');\n        }\n        this.baseDir = baseDir;\n    }\n\n    /**\n     * static helpers for capturing stdout report output;\n     * super useful for tests!\n     */\n    static startCapture() {\n        capture = true;\n    }\n\n    static stopCapture() {\n        capture = false;\n    }\n\n    static getOutput() {\n        return output;\n    }\n\n    static resetOutput() {\n        output = '';\n    }\n\n    /**\n     * returns a FileWriter that is rooted at the supplied subdirectory\n     * @param {String} subdir the subdirectory under which to root the\n     *  returned FileWriter\n     * @returns {FileWriter}\n     */\n    writerForDir(subdir) {\n        if (path.isAbsolute(subdir)) {\n            throw new Error(\n                `Cannot create subdir writer for absolute path: ${subdir}`\n            );\n        }\n        return new FileWriter(`${this.baseDir}/${subdir}`);\n    }\n\n    /**\n     * copies a file from a source directory to a destination name\n     * @param {String} source path to source file\n     * @param {String} dest relative path to destination file\n     * @param {String} [header=undefined] optional text to prepend to destination\n     *  (e.g., an \"this file is autogenerated\" comment, copyright notice, etc.)\n     */\n    copyFile(source, dest, header) {\n        if (path.isAbsolute(dest)) {\n            throw new Error(`Cannot write to absolute path: ${dest}`);\n        }\n        dest = path.resolve(this.baseDir, dest);\n        mkdirp.sync(path.dirname(dest));\n        let contents;\n        if (header) {\n            contents = header + fs.readFileSync(source, 'utf8');\n        } else {\n            contents = fs.readFileSync(source);\n        }\n        fs.writeFileSync(dest, contents);\n    }\n\n    /**\n     * returns a content writer for writing content to the supplied file.\n     * @param {String|null} file the relative path to the file or the special\n     *  values `\"-\"` or `null` for writing to the console\n     * @returns {ContentWriter}\n     */\n    writeFile(file) {\n        if (file === null || file === '-') {\n            return new ConsoleWriter();\n        }\n        if (path.isAbsolute(file)) {\n            throw new Error(`Cannot write to absolute path: ${file}`);\n        }\n        file = path.resolve(this.baseDir, file);\n        mkdirp.sync(path.dirname(file));\n        return new FileContentWriter(fs.openSync(file, 'w'));\n    }\n}\n\nmodule.exports = FileWriter;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMC,EAAE,GAAGD,OAAO,CAAC,IAAI,CAAC;AACxB,MAAME,MAAM,GAAGF,OAAO,CAAC,UAAU,CAAC;AAClC,MAAMG,aAAa,GAAGH,OAAO,CAAC,gBAAgB,CAAC;;AAE/C;AACA;AACA;AACA;AACA;AACA,MAAMI,aAAa,CAAC;EAChB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,QAAQ,CAACC,GAAG,CAAC,aAAa;IACtB,OAAOA,GAAG;EACd;;EAEA;AACJ;AACA;AACA;EACIC,OAAO,CAACD,GAAG,EAAE;IACT,IAAI,CAACE,KAAK,CAAE,GAAEF,GAAI,IAAG,CAAC;EAC1B;;EAEA;AACJ;AACA;EACIG,KAAK,GAAG,CAAC;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,iBAAiB,SAASN,aAAa,CAAC;EAC1CO,WAAW,CAACC,EAAE,EAAE;IACZ,KAAK,EAAE;IAEP,IAAI,CAACA,EAAE,GAAGA,EAAE;EAChB;EAEAJ,KAAK,CAACF,GAAG,EAAE;IACPL,EAAE,CAACY,SAAS,CAAC,IAAI,CAACD,EAAE,EAAEN,GAAG,CAAC;EAC9B;EAEAG,KAAK,GAAG;IACJR,EAAE,CAACa,SAAS,CAAC,IAAI,CAACF,EAAE,CAAC;EACzB;AACJ;;AAEA;AACA,IAAIG,OAAO,GAAG,KAAK;AACnB,IAAIC,MAAM,GAAG,EAAE;;AAEf;AACA;AACA;AACA;AACA;AACA,MAAMC,aAAa,SAASb,aAAa,CAAC;EACtCI,KAAK,CAACF,GAAG,EAAE;IACP,IAAIS,OAAO,EAAE;MACTC,MAAM,IAAIV,GAAG;IACjB,CAAC,MAAM;MACHY,OAAO,CAACC,MAAM,CAACX,KAAK,CAACF,GAAG,CAAC;IAC7B;EACJ;EAEAD,QAAQ,CAACC,GAAG,EAAEc,KAAK,EAAE;IACjB,MAAMC,MAAM,GAAG;MACXC,GAAG,EAAE,MAAM;MACXC,MAAM,EAAE,MAAM;MACdC,IAAI,EAAE;IACV,CAAC;;IAED;IACA,IAAIrB,aAAa,CAACgB,MAAM,IAAIE,MAAM,CAACD,KAAK,CAAC,EAAE;MACvC,OAAQ,UAASC,MAAM,CAACD,KAAK,CAAE,IAAGd,GAAI,WAAU;IACpD;IACA,OAAOA,GAAG;EACd;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMmB,UAAU,CAAC;EACbd,WAAW,CAACe,OAAO,EAAE;IACjB,IAAI,CAACA,OAAO,EAAE;MACV,MAAM,IAAIC,KAAK,CAAC,2BAA2B,CAAC;IAChD;IACA,IAAI,CAACD,OAAO,GAAGA,OAAO;EAC1B;;EAEA;AACJ;AACA;AACA;EACI,OAAOE,YAAY,GAAG;IAClBb,OAAO,GAAG,IAAI;EAClB;EAEA,OAAOc,WAAW,GAAG;IACjBd,OAAO,GAAG,KAAK;EACnB;EAEA,OAAOe,SAAS,GAAG;IACf,OAAOd,MAAM;EACjB;EAEA,OAAOe,WAAW,GAAG;IACjBf,MAAM,GAAG,EAAE;EACf;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIgB,YAAY,CAACC,MAAM,EAAE;IACjB,IAAIlC,IAAI,CAACmC,UAAU,CAACD,MAAM,CAAC,EAAE;MACzB,MAAM,IAAIN,KAAK,CACV,kDAAiDM,MAAO,EAAC,CAC7D;IACL;IACA,OAAO,IAAIR,UAAU,CAAE,GAAE,IAAI,CAACC,OAAQ,IAAGO,MAAO,EAAC,CAAC;EACtD;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIE,QAAQ,CAACC,MAAM,EAAEC,IAAI,EAAEC,MAAM,EAAE;IAC3B,IAAIvC,IAAI,CAACmC,UAAU,CAACG,IAAI,CAAC,EAAE;MACvB,MAAM,IAAIV,KAAK,CAAE,kCAAiCU,IAAK,EAAC,CAAC;IAC7D;IACAA,IAAI,GAAGtC,IAAI,CAACwC,OAAO,CAAC,IAAI,CAACb,OAAO,EAAEW,IAAI,CAAC;IACvCnC,MAAM,CAACsC,IAAI,CAACzC,IAAI,CAAC0C,OAAO,CAACJ,IAAI,CAAC,CAAC;IAC/B,IAAIK,QAAQ;IACZ,IAAIJ,MAAM,EAAE;MACRI,QAAQ,GAAGJ,MAAM,GAAGrC,EAAE,CAAC0C,YAAY,CAACP,MAAM,EAAE,MAAM,CAAC;IACvD,CAAC,MAAM;MACHM,QAAQ,GAAGzC,EAAE,CAAC0C,YAAY,CAACP,MAAM,CAAC;IACtC;IACAnC,EAAE,CAAC2C,aAAa,CAACP,IAAI,EAAEK,QAAQ,CAAC;EACpC;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIG,SAAS,CAACC,IAAI,EAAE;IACZ,IAAIA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,GAAG,EAAE;MAC/B,OAAO,IAAI7B,aAAa,EAAE;IAC9B;IACA,IAAIlB,IAAI,CAACmC,UAAU,CAACY,IAAI,CAAC,EAAE;MACvB,MAAM,IAAInB,KAAK,CAAE,kCAAiCmB,IAAK,EAAC,CAAC;IAC7D;IACAA,IAAI,GAAG/C,IAAI,CAACwC,OAAO,CAAC,IAAI,CAACb,OAAO,EAAEoB,IAAI,CAAC;IACvC5C,MAAM,CAACsC,IAAI,CAACzC,IAAI,CAAC0C,OAAO,CAACK,IAAI,CAAC,CAAC;IAC/B,OAAO,IAAIpC,iBAAiB,CAACT,EAAE,CAAC8C,QAAQ,CAACD,IAAI,EAAE,GAAG,CAAC,CAAC;EACxD;AACJ;AAEAE,MAAM,CAACC,OAAO,GAAGxB,UAAU"},"metadata":{},"sourceType":"script","externalDependencies":[]}