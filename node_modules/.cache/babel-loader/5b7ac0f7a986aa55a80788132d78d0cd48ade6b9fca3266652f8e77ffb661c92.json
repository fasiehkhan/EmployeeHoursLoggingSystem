{"ast":null,"code":"'use strict';\n\n/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nconst INDENT = '  ';\nfunction attrString(attrs) {\n  return Object.entries(attrs || {}).map(_ref => {\n    let [k, v] = _ref;\n    return ` ${k}=\"${v}\"`;\n  }).join('');\n}\n\n/**\n * a utility class to produce well-formed, indented XML\n * @param {ContentWriter} contentWriter the content writer that this utility wraps\n * @constructor\n */\nclass XMLWriter {\n  constructor(contentWriter) {\n    this.cw = contentWriter;\n    this.stack = [];\n  }\n  indent(str) {\n    return this.stack.map(() => INDENT).join('') + str;\n  }\n\n  /**\n   * writes the opening XML tag with the supplied attributes\n   * @param {String} name tag name\n   * @param {Object} [attrs=null] attrs attributes for the tag\n   */\n  openTag(name, attrs) {\n    const str = this.indent(`<${name + attrString(attrs)}>`);\n    this.cw.println(str);\n    this.stack.push(name);\n  }\n\n  /**\n   * closes an open XML tag.\n   * @param {String} name - tag name to close. This must match the writer's\n   *  notion of the tag that is currently open.\n   */\n  closeTag(name) {\n    if (this.stack.length === 0) {\n      throw new Error(`Attempt to close tag ${name} when not opened`);\n    }\n    const stashed = this.stack.pop();\n    const str = `</${name}>`;\n    if (stashed !== name) {\n      throw new Error(`Attempt to close tag ${name} when ${stashed} was the one open`);\n    }\n    this.cw.println(this.indent(str));\n  }\n\n  /**\n   * writes a tag and its value opening and closing it at the same time\n   * @param {String} name tag name\n   * @param {Object} [attrs=null] attrs tag attributes\n   * @param {String} [content=null] content optional tag content\n   */\n  inlineTag(name, attrs, content) {\n    let str = '<' + name + attrString(attrs);\n    if (content) {\n      str += `>${content}</${name}>`;\n    } else {\n      str += '/>';\n    }\n    str = this.indent(str);\n    this.cw.println(str);\n  }\n\n  /**\n   * closes all open tags and ends the document\n   */\n  closeAll() {\n    this.stack.slice().reverse().forEach(name => {\n      this.closeTag(name);\n    });\n  }\n}\nmodule.exports = XMLWriter;","map":{"version":3,"names":["INDENT","attrString","attrs","Object","entries","map","k","v","join","XMLWriter","constructor","contentWriter","cw","stack","indent","str","openTag","name","println","push","closeTag","length","Error","stashed","pop","inlineTag","content","closeAll","slice","reverse","forEach","module","exports"],"sources":["/Users/fasiehkhan/Documents/GitHub/EmployeeHoursLoggingSystem/node_modules/istanbul-lib-report/lib/xml-writer.js"],"sourcesContent":["'use strict';\n/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nconst INDENT = '  ';\n\nfunction attrString(attrs) {\n    return Object.entries(attrs || {})\n        .map(([k, v]) => ` ${k}=\"${v}\"`)\n        .join('');\n}\n\n/**\n * a utility class to produce well-formed, indented XML\n * @param {ContentWriter} contentWriter the content writer that this utility wraps\n * @constructor\n */\nclass XMLWriter {\n    constructor(contentWriter) {\n        this.cw = contentWriter;\n        this.stack = [];\n    }\n\n    indent(str) {\n        return this.stack.map(() => INDENT).join('') + str;\n    }\n\n    /**\n     * writes the opening XML tag with the supplied attributes\n     * @param {String} name tag name\n     * @param {Object} [attrs=null] attrs attributes for the tag\n     */\n    openTag(name, attrs) {\n        const str = this.indent(`<${name + attrString(attrs)}>`);\n        this.cw.println(str);\n        this.stack.push(name);\n    }\n\n    /**\n     * closes an open XML tag.\n     * @param {String} name - tag name to close. This must match the writer's\n     *  notion of the tag that is currently open.\n     */\n    closeTag(name) {\n        if (this.stack.length === 0) {\n            throw new Error(`Attempt to close tag ${name} when not opened`);\n        }\n        const stashed = this.stack.pop();\n        const str = `</${name}>`;\n\n        if (stashed !== name) {\n            throw new Error(\n                `Attempt to close tag ${name} when ${stashed} was the one open`\n            );\n        }\n        this.cw.println(this.indent(str));\n    }\n\n    /**\n     * writes a tag and its value opening and closing it at the same time\n     * @param {String} name tag name\n     * @param {Object} [attrs=null] attrs tag attributes\n     * @param {String} [content=null] content optional tag content\n     */\n    inlineTag(name, attrs, content) {\n        let str = '<' + name + attrString(attrs);\n        if (content) {\n            str += `>${content}</${name}>`;\n        } else {\n            str += '/>';\n        }\n        str = this.indent(str);\n        this.cw.println(str);\n    }\n\n    /**\n     * closes all open tags and ends the document\n     */\n    closeAll() {\n        this.stack\n            .slice()\n            .reverse()\n            .forEach(name => {\n                this.closeTag(name);\n            });\n    }\n}\n\nmodule.exports = XMLWriter;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA,MAAMA,MAAM,GAAG,IAAI;AAEnB,SAASC,UAAU,CAACC,KAAK,EAAE;EACvB,OAAOC,MAAM,CAACC,OAAO,CAACF,KAAK,IAAI,CAAC,CAAC,CAAC,CAC7BG,GAAG,CAAC;IAAA,IAAC,CAACC,CAAC,EAAEC,CAAC,CAAC;IAAA,OAAM,IAAGD,CAAE,KAAIC,CAAE,GAAE;EAAA,EAAC,CAC/BC,IAAI,CAAC,EAAE,CAAC;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMC,SAAS,CAAC;EACZC,WAAW,CAACC,aAAa,EAAE;IACvB,IAAI,CAACC,EAAE,GAAGD,aAAa;IACvB,IAAI,CAACE,KAAK,GAAG,EAAE;EACnB;EAEAC,MAAM,CAACC,GAAG,EAAE;IACR,OAAO,IAAI,CAACF,KAAK,CAACR,GAAG,CAAC,MAAML,MAAM,CAAC,CAACQ,IAAI,CAAC,EAAE,CAAC,GAAGO,GAAG;EACtD;;EAEA;AACJ;AACA;AACA;AACA;EACIC,OAAO,CAACC,IAAI,EAAEf,KAAK,EAAE;IACjB,MAAMa,GAAG,GAAG,IAAI,CAACD,MAAM,CAAE,IAAGG,IAAI,GAAGhB,UAAU,CAACC,KAAK,CAAE,GAAE,CAAC;IACxD,IAAI,CAACU,EAAE,CAACM,OAAO,CAACH,GAAG,CAAC;IACpB,IAAI,CAACF,KAAK,CAACM,IAAI,CAACF,IAAI,CAAC;EACzB;;EAEA;AACJ;AACA;AACA;AACA;EACIG,QAAQ,CAACH,IAAI,EAAE;IACX,IAAI,IAAI,CAACJ,KAAK,CAACQ,MAAM,KAAK,CAAC,EAAE;MACzB,MAAM,IAAIC,KAAK,CAAE,wBAAuBL,IAAK,kBAAiB,CAAC;IACnE;IACA,MAAMM,OAAO,GAAG,IAAI,CAACV,KAAK,CAACW,GAAG,EAAE;IAChC,MAAMT,GAAG,GAAI,KAAIE,IAAK,GAAE;IAExB,IAAIM,OAAO,KAAKN,IAAI,EAAE;MAClB,MAAM,IAAIK,KAAK,CACV,wBAAuBL,IAAK,SAAQM,OAAQ,mBAAkB,CAClE;IACL;IACA,IAAI,CAACX,EAAE,CAACM,OAAO,CAAC,IAAI,CAACJ,MAAM,CAACC,GAAG,CAAC,CAAC;EACrC;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIU,SAAS,CAACR,IAAI,EAAEf,KAAK,EAAEwB,OAAO,EAAE;IAC5B,IAAIX,GAAG,GAAG,GAAG,GAAGE,IAAI,GAAGhB,UAAU,CAACC,KAAK,CAAC;IACxC,IAAIwB,OAAO,EAAE;MACTX,GAAG,IAAK,IAAGW,OAAQ,KAAIT,IAAK,GAAE;IAClC,CAAC,MAAM;MACHF,GAAG,IAAI,IAAI;IACf;IACAA,GAAG,GAAG,IAAI,CAACD,MAAM,CAACC,GAAG,CAAC;IACtB,IAAI,CAACH,EAAE,CAACM,OAAO,CAACH,GAAG,CAAC;EACxB;;EAEA;AACJ;AACA;EACIY,QAAQ,GAAG;IACP,IAAI,CAACd,KAAK,CACLe,KAAK,EAAE,CACPC,OAAO,EAAE,CACTC,OAAO,CAACb,IAAI,IAAI;MACb,IAAI,CAACG,QAAQ,CAACH,IAAI,CAAC;IACvB,CAAC,CAAC;EACV;AACJ;AAEAc,MAAM,CAACC,OAAO,GAAGvB,SAAS"},"metadata":{},"sourceType":"script","externalDependencies":[]}